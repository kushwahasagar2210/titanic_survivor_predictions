# -*- coding: utf-8 -*-
"""titanic_survivor_predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oBPtLIaJG1R1YDjJ6OOFQieq8_3DnMEQ
"""

# Titanic Survival Predictor - end-to-end


import os, json, re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.metrics import (accuracy_score, precision_score, recall_score, f1_score,
                             roc_auc_score, confusion_matrix, RocCurveDisplay, classification_report)
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier


train_path = "titanic_train.csv"
test_path  = "titanic_test.csv"

train_df = pd.read_csv("/content/drive/MyDrive/titanic_train.csv")
test_df  = pd.read_csv("/content/drive/MyDrive/titanic_test.csv")

print("Train shape:", train_df.shape)
print("Test shape:", test_df.shape)

# Preprocessing function
def extract_title(name):
    m = re.search(r",\s*([^\.]+)\.", name)
    return m.group(1).strip() if m else "None"

def preprocess(df_in, is_train=True):
    df = df_in.copy()

    # Extract title from Name
    df["Title"] = df["Name"].apply(extract_title)
    title_map = {
        "Mlle":"Miss", "Ms":"Miss", "Mme":"Mrs",
        "Lady":"Rare", "Countess":"Rare", "Capt":"Rare", "Col":"Rare",
        "Don":"Rare", "Dr":"Rare", "Major":"Rare", "Rev":"Rare",
        "Sir":"Rare", "Jonkheer":"Rare", "Dona":"Rare"
    }
    df["Title"] = df["Title"].replace(title_map)

    # Family features
    df["FamilySize"] = df["SibSp"] + df["Parch"] + 1
    df["IsAlone"] = (df["FamilySize"] == 1).astype(int)

    # Cabin deck
    df["CabinDeck"] = df["Cabin"].astype(str).str[0]
    df.loc[df["CabinDeck"] == "n", "CabinDeck"] = "Unknown"

    # Fill missing values
    if df["Embarked"].isna().any():
        df["Embarked"].fillna(df["Embarked"].mode()[0], inplace=True)

    if df["Fare"].isna().any():
        df["Fare"] = df.groupby("Pclass")["Fare"].transform(lambda s: s.fillna(s.median()))

    if "Age" in df.columns:
        age_grp = df.groupby(["Title", "Pclass", "Sex"])["Age"].median()
        def impute_age(row):
            if pd.isna(row["Age"]):
                return age_grp.loc[row["Title"], row["Pclass"], row["Sex"]]
            return row["Age"]
        df["Age"] = df.apply(impute_age, axis=1)

    # Select useful columns
    keep_cols = ["Survived","Pclass","Sex","Age","SibSp","Parch","Fare","Embarked",
                 "Title","FamilySize","IsAlone","CabinDeck","Ticket"]
    keep_cols = [c for c in keep_cols if c in df.columns]
    df = df[keep_cols]

    # Ticket group size
    if "Ticket" in df.columns:
        df["TicketGroupSize"] = df.groupby("Ticket")["Ticket"].transform("count")
        df.drop(columns=["Ticket"], inplace=True)

    return df

train_clean = preprocess(train_df, is_train=True)
test_clean  = preprocess(test_df, is_train=False)

# Save cleaned versions
os.makedirs("data", exist_ok=True)
train_clean.to_csv("data/train_cleaned.csv", index=False)
test_clean.to_csv("data/test_cleaned.csv", index=False)

# ---------- 3) EDA
os.makedirs("reports/figures", exist_ok=True)

def bar_plot(series, title, fname):
    plt.figure()
    series.value_counts().plot(kind="bar")
    plt.title(title)
    plt.savefig(f"reports/figures/{fname}")
    plt.close()

bar_plot(train_clean["Sex"], "Sex distribution", "sex.png")
bar_plot(train_clean["Pclass"], "Passenger Class", "pclass.png")

# ---------- 4) Train/Validation Split
X = train_clean.drop(columns=["Survived"])
y = train_clean["Survived"]

X_train, X_valid, y_train, y_valid = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# ---------- 5) Models
numeric_features = ["Age","SibSp","Parch","Fare","FamilySize","TicketGroupSize"]
numeric_features = [f for f in numeric_features if f in X.columns]
categorical_features = ["Pclass","Sex","Embarked","Title","IsAlone","CabinDeck"]
categorical_features = [f for f in categorical_features if f in X.columns]

preprocess_ct = ColumnTransformer([
    ("num", StandardScaler(with_mean=False), numeric_features),
    ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features),
])

models = {
    "logreg": LogisticRegression(max_iter=200),
    "rf": RandomForestClassifier(random_state=42),
    "gb": GradientBoostingClassifier(random_state=42),
}

pipelines = {name: Pipeline([("pre", preprocess_ct), ("model", mdl)]) for name, mdl in models.items()}

param_grid = {
    "logreg": {"model__C": [0.1, 1.0, 3.0]},
    "rf": {"model__n_estimators": [200, 500], "model__max_depth": [None, 5, 10]},
    "gb": {"model__n_estimators": [100, 300], "model__learning_rate": [0.05, 0.1], "model__max_depth": [2, 3]},
}

cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

def train_and_eval(name, pipe, grid):
    gs = GridSearchCV(pipe, grid, cv=cv, scoring="accuracy", n_jobs=-1)
    gs.fit(X_train, y_train)
    best = gs.best_estimator_
    preds = best.predict(X_valid)
    proba = best.predict_proba(X_valid)[:,1] if hasattr(best, "predict_proba") else None

    results = {
        "model": name,
        "best_params": gs.best_params_,
        "valid_accuracy": accuracy_score(y_valid, preds),
        "valid_precision": precision_score(y_valid, preds),
        "valid_recall": recall_score(y_valid, preds),
        "valid_f1": f1_score(y_valid, preds),
    }
    if proba is not None:
        results["valid_roc_auc"] = roc_auc_score(y_valid, proba)
    return results, best

all_results = []
best_model = None
best_score = -1

for name, pipe in pipelines.items():
    res, model = train_and_eval(name, pipe, param_grid[name])
    all_results.append(res)
    if res["valid_f1"] > best_score:
        best_score = res["valid_f1"]
        best_model = (name, model, res)

print("Validation results:")
print(pd.DataFrame(all_results))

name, model, res = best_model
print("\nBest model:", name)
print(res)

print("\nClassification Report:")
print(classification_report(y_valid, model.predict(X_valid)))